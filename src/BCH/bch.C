#include <numeric>
#include "CoCoA/library.H"
#include "ecc/bch.H"

using namespace std;

namespace CoCoA {

    // d = Designed distance
    // f = Primitive polynomial, dependent on "alpha"
    // f could be generated by, e.g., https://www.researchgate.net/publication/251501522
    RingElem bchGenPoly(const int c, const int d, const int p,
                        const string &f) {
        const QuotientRing Fp = NewZZmod(p);
        const SparsePolyRing Fpx = NewPolyRing(Fp, symbols("alpha,x"));
        const RingElem alpha = indet(Fpx, 0);
        const RingElem x = indet(Fpx, 1);
        const RingElem r = RingElem(Fpx, f);
        const ideal I(r);

        RingElem ret = one(Fpx);
        for (long i = c; i <= c + d - 2; ++i)
            ret = lcm(ret, MinPolyQuot(power(alpha, i), I, x));
        return ret;
    }

    // f: Polynomial to find roots of
    // a: Primitive element in field
    // qn: Amount of elements in field
    // x: Variable x
    vector<long> ChienSearch(ConstRefRingElem f, ConstRefRingElem a,
                             const long qn, ConstRefRingElem x) {
        const ring &R = owner(f);
        const RingElem z = zero(R);
        const long n = deg(f);
        vector<long> rootPowers = {};
        vector<RingElem> b = CoeffVecWRT(f, x);
        for (long i = 0; i < qn - 1; ++i) {
            if (IsZero(accumulate(b.cbegin(), b.cend(), z))) {
                const long currPower = i - qn + 1;
                rootPowers.push_back(currPower % (qn - 1));
            }
            for (long j = 0; j <= n; ++j)
                b[j] *= power(a, j);
        }
        return rootPowers;
    }

    // From Jungnickel
    RingElem PetersonGorensteinZierler(const BCH &bch, ConstRefRingElem p,
                                       ConstRefRingElem x,
                                       const vector<RingElem> &s, long v) {
        const ring &Px = owner(p);

        if (all_of(s.cbegin(), s.cend(),
                   [](const RingElem &r) { return IsZero(r); }))
            return zero(Px);

        matrix M = NewDenseMat(Px, v, v);
        for (long i = 0; i < v; ++i)
            for (long j = 0; j < v; ++j)
                SetEntry(M, i, j, s[i + j]);

        bool zd;
        do {
            // Resizing suffices since the entries do not change
            M->myResize(v, v);
            zd = IsZeroDet(M);
            if (zd && v == 1) CoCoA_THROW_ERROR("Cannot decode!", "BCH");
            --v;
        } while (zd && v != 0);

        const long w = v + 1;
        matrix V = NewDenseMat(Px, w, 1);
        for (long i = 0; i < w; ++i)
            SetEntry(V, i, 0, s[w + i]);

        // Sadly NYI: const matrix P = LinSolve(M, -V);
        const matrix P = -inverse(M) * V;

        RingElem ret = one(Px);
        for (long i = 0; i < w; ++i)
            ret += P(w - i - 1, 0) * power(x, i + 1);
        return ret;
    }

    RingElem Forney(const BCH &bch, const vector<RingElem> &s,
                    ConstRefRingElem e, const vector<long> &roots,
                    ConstRefRingElem x) {
        const ring &Px = owner(e);

        RingElem S = zero(Px);
        for (long i = 0; i < s.size(); ++i)
            S += s[i] * power(x, i);

        const RingElem O = NR(S * e, {power(x, bch.d - 1)});
        const RingElem ed = deriv(e, x);

        RingElem ret = zero(Px);
        for (long k: roots) {
            const RingHom eval = PolyAlgebraHom(
                    Px, Px, {power(bch.a, k)});
            ret += -power(x, -k) * (power(bch.a, -k) * eval(O))
                   / (power(bch.a, -bch.c * k) * eval(ed));
        }
        return ret;
    }

    RingElem encodeBCH(const BCH &bch, ConstRefRingElem p, ConstRefRingElem x) {
        const RingElem px = p * power(x, bch.n - bch.k);
        const RingElem r = NR(px, {bch.g});
        return px - r;
    }

    RingElem decodeBCH(const BCH &bch, ConstRefRingElem p, ConstRefRingElem x) {
        const ring &Px = owner(p);
        const long t = (bch.d - 1) / 2;

        // Calculate syndromes
        vector<RingElem> s(bch.d - 1, zero(Px));
        for (long j = 0; j <= bch.d - 2; ++j) {
            const RingHom eval = PolyAlgebraHom(
                    Px, Px, {power(bch.a, bch.c + j)});
            s[j] = eval(p);
        }

        // Calculate error locator polynomial using the
        // Peterson-Gorenstein-Zierler algorithm
        const RingElem e = PetersonGorensteinZierler(bch, p, x, s, t);
        if (IsZero(e)) return p;

        // Factor error locator polynomial using Chien Search
        const vector<long> roots = ChienSearch(e, bch.a, bch.qn, x);
        if (roots.empty()) return p;

        // Calculate error values using Forney's algorithm and correct errors
        if (bch.q == 2) {
            RingElem f = p;
            for (long j: roots)
                f -= power(x, -j);
            return f;
        } else {
            return p - Forney(bch, s, e, roots, x);
        }
    }

}
