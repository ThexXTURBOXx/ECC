#include "CoCoA/library.H"
#include "types/cyclic.H"
#include "ecc/bch.H"
#include "util/utils.H"

using namespace std;

namespace CoCoA {

  // d = Designed distance
  // f = Primitive polynomial, dependent on "alpha"
  // f could be generated by, e.g., https://www.researchgate.net/publication/251501522
  RingElem bchGenPoly(const int c, const int d, const int p, const string &f) {
    const QuotientRing Fp = NewZZmod(p);
    const SparsePolyRing Fpx = NewPolyRing(Fp, symbols("alpha,x"));
    const RingElem &x = indet(Fpx, 1);
    const RingElem r = RingElem(Fpx, f);
    const ideal I(r);

    RingElem ret = one(Fpx);
    for (long i = c; i <= c + d - 2; ++i)
      ret = lcm(ret, MinPolyQuot(IndetPower(Fpx, 0, i), I, x));
    return ret;
  }

  // From Jungnickel
  RingElem PetersonGorensteinZierler(ConstRefRingElem p, ConstRefRingElem x, const vector<RingElem> &s, long v) {
    const ring &Px = owner(p);

    if (all_of(s.cbegin(), s.cend(),
               [](const RingElem &r) {
                 return IsZero(r);
               }))
      return zero(Px);

    matrix M = NewDenseMat(Px, v, v);
    for (long i = 0; i < v; ++i)
      for (long j = 0; j < v; ++j)
        SetEntry(M, i, j, s[i + j]);

    bool zd;
    do {
      // Resizing suffices since the entries do not change
      M->myResize(v, v);
      zd = IsZeroDet(M);
      if (zd && v==1)
        CoCoA_THROW_ERROR("Cannot decode!", "BCH");
      --v;
    } while (zd && v!=0);

    const long w = v + 1;
    matrix V = NewDenseMat(Px, w, 1);
    for (long i = 0; i < w; ++i)
      SetEntry(V, i, 0, s[w + i]);

    // Sadly NYI: const matrix P = LinSolve(M, -V);
    const matrix P = -inverse(M) * V;

    RingElem ret = one(Px);
    for (long i = 0; i < w; ++i)
      ret += P(w - i - 1, 0) * power(x, i + 1);
    return ret;
  }

  RingElem Forney(const BCH &bch, const vector<RingElem> &s, ConstRefRingElem e, const vector<long> &roots,
                  ConstRefRingElem x) {
    const ring &Px = owner(e);

    RingElem S = zero(Px);
    for (long i = 0; i < s.size(); ++i)
      S += s[i] * power(x, i);

    const RingElem O = NR(S * e, {power(x, bch.d - 1)});
    const RingElem ed = deriv(e, x);

    RingElem ret = zero(Px);
    for (long k: roots) {
      const long revK = (k - bch.qn + 1) % (bch.qn - 1);
      const RingHom eval = PolyAlgebraHom(
          Px, Px, {power(bch.a, revK)});
      ret += -power(x, -revK) * (power(bch.a, -revK) * eval(O)) / (power(bch.a, -bch.c * revK) * eval(ed));
    }
    return ret;
  }

  RingElem encodeBCH(const BCH &bch, ConstRefRingElem p) {
    return sysEncodeCyclic(bch.g, p, bch.x, bch.n, bch.k);
  }

  RingElem decodeBCH(const BCH &bch, ConstRefRingElem p) {
    const ring &Px = owner(p);
    const long t = (bch.d - 1) / 2;

    // Calculate syndromes
    vector<RingElem> s(bch.d - 1, zero(Px));
    for (long j = 0; j <= bch.d - 2; ++j) {
      const RingHom eval = PolyAlgebraHom(
          Px, Px, {power(bch.a, bch.c + j)});
      s[j] = eval(p);
    }

    // Calculate error locator polynomial using the
    // Peterson-Gorenstein-Zierler algorithm
    const RingElem e = PetersonGorensteinZierler(p, bch.x, s, t);
    if (IsZero(e))
      return p;

    // Factor error locator polynomial using Chien Search
    const vector<long> roots = ChienSearch(e, bch.a, bch.qn, bch.x);
    if (roots.empty())
      return p;

    // Calculate error values using Forney's algorithm and correct errors
    if (bch.q==2) {
      RingElem f = p;
      for (long j: roots)
        f -= power(bch.x, -((j - bch.qn + 1) % (bch.qn - 1)));
      return f;
    } else {
      return p - Forney(bch, s, e, roots, bch.x);
    }
  }

}
